
### 05 책임과 메세지
> 성장가능한 시스템을 만들기 위한 핵심은 어떻게 커뮤니케이션하는가에 달렸다</br>
방관자 효과, 역할.책임이 흐릿할수록 객체를 도와줄 협력자를 찾기 힘들다.

#### 자율적인 책임
##### 설계의 품질을 좌우하는 책임
*자율성* : 객체가 얼마나 자율적인지가 전체 애플리케이션의 품질을 결정함.
- 적절한 책임을 적절한 객체에 할당

##### 자신의 의지에 따라 증언할 수 있는 자유
모자 장수에게 _증언하라_  라고 요청하면 모자장수는 자유롭게 증언할 수 있음. 그러나 모자 장수에게 시간순을 지켜서, 말로써 증언하라 등의 요청을 한다면 자유도가 떨어진다.
- 객체가 자율적이기 위해서는 객체에 할당되는 책임의 수준도 자율적이어야 한다.

##### 너무 추상적인 책임
- 문맥에 따라 적합한 책임이 달라질 수 있음.
 - ex) 모자장수에게 ‘증언하라’ 적절O
 - 모자장수에게 ‘설명하라’ 너무 추상적이다.

##### ‘어떻게‘가 아니라 ‘무엇’을
- 무엇을 해야하는지를 정의해야함

##### 책임을 자극하는 메세지
> 행동을 수행하게 만드는 유일한 방법, 메세지

#### 메세지와 메서드
##### 메세지
> 객체가 다른 객체에 접근할 수 있는 유일한 방법<br>
_받는사람, 메세지 이름, 인자_ 의 조합 -> 메세지
객체 외부 : 메세지를 받음
객체 내부 : 메세지에 대한 내용을 처리함 (방법, 자율, 메서드)

##### 메서드
> 요청을 받는 사람에 의해 어떤 메소드가 실행될지 결정된다

##### 다형성
> 서로 다른 유형의 객체가 동일하ㅏㄴ 메세지에 대해 서로 다르게 반응하는 것을 의미<br>
> 1개의 메세지 -> 여러개의 메소드
왕 “증언하라” -> 모자장수 (얘기해줌), 앨리스(공책에 증언해서 제출함)… 등등 다양한 방법이 될 수 있다. -> 왕의 입장에서 증언이라는 응답을 받는 것을 동일하게 생각함. (대체 가능, 캡슐화)
- 객체들의 대체 가능성을 이용해 설계 유연, 재사용 가능
- (요청)수신자를 캡슐화함.
> 송신자, 수신자 사이의 객체 타입에 대한 결합도를 메세지에 대한 결합도로 낮춤으로써 달성 </br>
> -> 객체 타입은 하나로 묶어지고(캡슐), 메세지 하나에 모든 객체와 협력가능
- 객체지향이 유연, 확장가능, 재사용성 높게 된 것은 모두 이 다형성때문임.(중요)

##### 유연하고 확장 가능하고 재사용성이 높은 협력의 의미
송신자가 수신자에 대해 적은 정보만을 갖고있어도 협력이 가능한 것은 설계 품질에 큰영향을 미친다.
1. 협력이 유연해진다.  수신자를 다른 타입으로 바꾸어도 메세지만 이해하고 처리할 수 있으면 문제 없다.
2. 협력이 수행되는 방식을 확장할 수 있다.  수신자 교체를 해도 문제 없기때문에 수행 방식을 쉽게 수정할 수 있음.
3. 협력이 수행되는 방식을 재사용할 수 있다.  수신자(처리자)에 대한 유연성이 있기때문에

##### 송신자와 수신자를 약하게 연결하는 메세지
> 다형성이 존재할 수 있는 것은 메세지 덕분임.</br>
> 메세지는 송.수신자 사이의 결합도를 낮출 수 있게 해줌. 
- 설계의 품질을 높이려면 훌륭한 메세지를 선택해야한다.

#### 메세지를 따라라
##### 객체지향의 핵심, 메세지
- 클래스는 객체들의 특성과 행위를 정적인 텍스트로 표현하기 위해 사용하는 추상화 도구일 뿐
- 중요한것은 객체
 - 클래스를 먼저 정의하는 것이 아닌, 객체의 속성과 행위를 식별하는 것이 먼저다.
  - 클래스는 객체의 속성, 행위를 담는 틀이다.
- 메세지를 주고받는 동적인 객체들의 집합으로 바라보는 것이 시작임.

- 흔한 실수 : 데이터 구조를 먼저 생각하고 데이터 조작에 필요한 오퍼레이션을 나중에 고려하는 것..
 - 메세지가 아니라 데이터 중심으로 객체를 설계하는 것은 객체의 자율성을 저해한다.
- 중요
 - 어떤 객체가 어떤 메세지를 전송할 수 있는가?
 - 어떤 객체가 어떤 메세지를 이해할 수 있는가?
 - 메세지가 객체를 선택하게 해야함. 메세지 중심으로 설계해야함.

##### 책임-주도 설계 다시 살펴보기
1. 시스템의 책임을 객체의 책임으로 할당한다.
2. 객체의 책임을 완수하기 다른 객체의 도움이 필요하다면 어떤 메세지가 필요한지 결정
3. 메시지를 수신하기에 적합한 객체를 선택한다.
- 결과적으로 메세지가 수신자의 책임을 결정한다.

##### What/Who 사이클
> 어떤 행위(What)을 누가?(Who)
- What -> 메세지

1. 필요한 메세지(행위)를 먼저 결정
2. 누구에게 할당하나 것인지 결정

##### 묻지 말고 시켜라 (Tell, Don't Ask)
- 메세지부터 결정, 객체 고민은 하지말라
 - 메세지 송신자는 메세지 수신 객체의 내부를 모르기때문에 수신자의 캡슐화를 증진
 - 서로간의 내용을 모르기때문에 송/수신자가 느슨하게 결합됨.
 
##### 메세지를 믿어라
메세지를 중심으로 설계된 구조는 유연하고 확장가능, 재사용가능하다


----
### 객체 인터페이스
#### 인터페이스

##### 인터페이스 특징
1. 사용법만 익히면 내부 구조, 방식을 몰라도 대상을 조작, 의사전달을 할 수 있음.
2. 내부 동작이 변경되어도 인터페이스 사용자에게는 어떠한 영향도 미치지 않음.
3. 대상이 변경되도 동일한 인터페이스만 제공하면 문제 없이 상호작용할 수 있음.

##### 메세지가 인터페이스를 결정함
##### 공용 인터페이스
- 외부에 공개된 인터페이스
- 메세지 : 공용 인터페이스를 자극해서 책임을 수행하게 하는 것
- 책임 : 객체가 메세지를 수신했을 때 수행해야하는 객체의 행동
##### 책임, 메세지, 그리고 인터페이스
1. 객체의 책임은 자율적이어야 한다.  : 책임 수행방법을 결정할 수 있음
2. 메세지 : 메세지 수신 시 책임이 수행됨. 메세지와 메소드의 구분은 객체를 외/내부 두 개로 명확하게 분리하여 다형성, 유연성을 부여함.
3. 인터페이스 : 협력하기 위한 접점. 

#### 인터페이스와 구현의 분리
##### 객체 관점에서 생각하는 방법
1. 좀 더 추상적인 인터페이스
- 너무 구체적인 인터페이스는 객체의 자율성을 해침. 
2. 최소 인터페이스
- 실제 협력에 필요한 메세지만 인터페이스에 포함하고 노출한다. 그래야 내부 수정을해도 외부에 미치는 영향을 최소화할 수 있음.
3. 인터페이스와 구현 간에 차이가 있다는 점을 인식

##### 구현
- 상태를 어떻게 표현할 것인가는 구현에 해당
- 행동은 메세지를 수신했을 때 실행되는 메세지 처리 방법

##### 인터페이스와 구현의 분리 원칙
> 객체 설계의 핵심은 외부로 공개되는 인터페이스와 내부에 구현을 분할해 설계하는 것
- SW는 항상 변경되기때문에 객체의 모든 것이 공개되어있으면 내부적으로 영향을 받게됨.
- !! 내부를 수정하더래도 외부 인터페이스에 영향이 없어야함.

##### 캡슐화 ( 정보 은닉 ) 
- 구현을 외부로부터 감추는 것
1. 상태 행위의 캡슐화 ( 데이터 캡슐화 ) 
 - 데이터, 프로세스를 묶는 것이 객체
 - 자기 상태(데이터)를 스스로 관리해야 자율적인 객체임. 
2. 사적인 비밀의 캡슐화
 - 공용 인터페이스를 경계로 최대한 자율성을 보장받음
 
 #### 책임의 자율성이 협력의 품질을 결정한다.
 1. 자율적인 책임은 협력을 단순하게 만든다. (추상화)
  - ex) 증언하라! -> 단순, 떠오르는 시간 순서대로 재구성 후 말로 간결하게 증언하라 -> 복잡
 2. 자율적인 책임은 모자 장수의 외부와 내부를 명확하게 분리한다. (캡슐화)
 3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에영향을 미치지 않는다.
  - 떠오르는 시간 순서대로 재구성 후 말로 간결하게 증언하라 -> 1가지만 변해도 내부 수정해야함. 결합도가 높음.
 4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공함. (유연성, 재사용성)
  - ex) 증언하라! -> 누구에게나 적용할 수 있음. 재활용 가능
 5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할을 이해하기 쉬워짐. (객체의 응집도 높아짐)
  - 증인석에 입장하라, 증언하라 라는 책임이 모여서 모자장수의 역할이 명확해짐
  
  > 객체지향의 출발점은 책임을 자율적으로 만드는 것</br>
  > 이것은 메세지에 따라 달라진다.
 




















